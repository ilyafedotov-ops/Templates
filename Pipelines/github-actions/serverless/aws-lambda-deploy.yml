name: AWS Lambda Deployment Pipeline

on:
  push:
    branches: [main, develop]
    paths:
      - 'functions/aws/**'
      - 'infrastructure/aws/**'
      - '.github/workflows/aws-lambda-deploy.yml'
  pull_request:
    branches: [main]
    paths:
      - 'functions/aws/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      deployment_strategy:
        description: 'Deployment strategy'
        required: true
        default: 'canary'
        type: choice
        options:
          - canary
          - linear
          - all-at-once
      canary_percentage:
        description: 'Canary traffic percentage (if applicable)'
        required: false
        default: '10'

env:
  AWS_REGION: us-east-1
  LAMBDA_RUNTIME: nodejs18.x
  LAMBDA_ARCHITECTURE: arm64
  SAM_VERSION: 1.100.0
  TERRAFORM_VERSION: 1.5.7
  NODE_VERSION: 18.x
  PYTHON_VERSION: 3.11

permissions:
  id-token: write
  contents: read
  security-events: write
  actions: read

jobs:
  # Security and compliance scanning
  security-scan:
    name: Security and Compliance Scan
    runs-on: ubuntu-latest
    outputs:
      scan-status: ${{ steps.security-gate.outputs.status }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHub-Actions-Lambda-Deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Run Checkov for SAM/CloudFormation
        id: checkov
        uses: bridgecrewio/checkov-action@master
        with:
          directory: .
          framework: cloudformation,serverless
          output_format: sarif
          output_file_path: checkov.sarif
          skip_check: CKV_AWS_115,CKV_AWS_116,CKV_AWS_173

      - name: Upload Checkov results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: checkov.sarif

      - name: Lambda function security scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: 'functions/aws'
          format: 'sarif'
          output: 'trivy-lambda.sarif'
          severity: 'CRITICAL,HIGH'
          security-checks: 'vuln,secret,config'

      - name: Upload Trivy results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: trivy-lambda.sarif

      - name: OWASP dependency check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'aws-lambda-functions'
          path: 'functions/aws'
          format: 'SARIF'
          args: >
            --enableRetired
            --enableExperimental
            --nvdApiKey ${{ secrets.NVD_API_KEY }}

      - name: Secret scanning with TruffleHog
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.repository.default_branch }}
          head: HEAD
          extra_args: --debug --only-verified

      - name: SAST with Semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/owasp-top-ten
            p/nodejs
            p/python
          generateSarif: true

      - name: AWS Security Hub compliance check
        run: |
          # Check Security Hub findings
          CRITICAL_FINDINGS=$(aws securityhub get-findings \
            --filters '{"ProductArn": [{"Value": "arn:aws:securityhub:*:*:product/aws/guardduty", "Comparison": "EQUALS"}], "RecordState": [{"Value": "ACTIVE", "Comparison": "EQUALS"}], "SeverityLabel": [{"Value": "CRITICAL", "Comparison": "EQUALS"}]}' \
            --query 'Findings | length(@)' \
            --output text)
          
          if [ "$CRITICAL_FINDINGS" -gt 0 ]; then
            echo "Found $CRITICAL_FINDINGS critical Security Hub findings"
            exit 1
          fi

      - name: Security gate decision
        id: security-gate
        run: |
          echo "status=passed" >> $GITHUB_OUTPUT

  # Build and test Lambda functions
  build-test:
    name: Build and Test Lambda Functions
    runs-on: ubuntu-latest
    needs: security-scan
    strategy:
      matrix:
        runtime: [nodejs, python, java, go]
    outputs:
      artifact-hash: ${{ steps.package.outputs.hash }}
      artifact-path: ${{ steps.package.outputs.path }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        if: matrix.runtime == 'nodejs'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Setup Python
        if: matrix.runtime == 'python'
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Setup Java
        if: matrix.runtime == 'java'
        uses: actions/setup-java@v4
        with:
          distribution: 'corretto'
          java-version: '17'
          cache: 'gradle'

      - name: Setup Go
        if: matrix.runtime == 'go'
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'
          cache: true

      - name: Cache Lambda layers
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            ~/.cache/pip
            ~/.gradle/caches
            ~/go/pkg/mod
            layers/
          key: ${{ runner.os }}-lambda-${{ matrix.runtime }}-${{ hashFiles('**/package-lock.json', '**/requirements.txt', '**/build.gradle', '**/go.sum') }}

      - name: Install dependencies - Node.js
        if: matrix.runtime == 'nodejs'
        working-directory: functions/aws/${{ matrix.runtime }}
        run: |
          npm ci --production=false
          npm audit fix --audit-level=high
          npm run build

      - name: Install dependencies - Python
        if: matrix.runtime == 'python'
        working-directory: functions/aws/${{ matrix.runtime }}
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt -t ./
          pip install pytest pytest-cov boto3 moto safety bandit

      - name: Build - Java
        if: matrix.runtime == 'java'
        working-directory: functions/aws/${{ matrix.runtime }}
        run: |
          ./gradlew clean build
          ./gradlew dependencyCheckAnalyze

      - name: Build - Go
        if: matrix.runtime == 'go'
        working-directory: functions/aws/${{ matrix.runtime }}
        run: |
          go mod download
          go build -ldflags="-s -w" -o bootstrap
          go test -v ./...

      - name: Run unit tests
        working-directory: functions/aws/${{ matrix.runtime }}
        run: |
          if [ "${{ matrix.runtime }}" == "nodejs" ]; then
            npm test -- --coverage
            npm run lint
          elif [ "${{ matrix.runtime }}" == "python" ]; then
            pytest --cov=. --cov-report=xml
            bandit -r . -f json -o bandit-report.json
            safety check --json
          elif [ "${{ matrix.runtime }}" == "java" ]; then
            ./gradlew test jacocoTestReport
          elif [ "${{ matrix.runtime }}" == "go" ]; then
            go test -v -race -coverprofile=coverage.out ./...
            go vet ./...
          fi

      - name: Build Lambda layers
        run: |
          # Build shared layers
          cd layers
          
          # Runtime-specific layer
          if [ "${{ matrix.runtime }}" == "nodejs" ]; then
            cd nodejs
            npm ci --production
            zip -r ../nodejs-layer.zip .
          elif [ "${{ matrix.runtime }}" == "python" ]; then
            cd python
            pip install -r requirements.txt -t python/
            zip -r ../python-layer.zip python/
          fi

      - name: Package Lambda function
        id: package
        working-directory: functions/aws/${{ matrix.runtime }}
        run: |
          # Optimize and package
          if [ "${{ matrix.runtime }}" == "nodejs" ]; then
            # Tree-shake and minify
            npx webpack --mode production
            zip -r lambda-${{ matrix.runtime }}.zip dist/ node_modules/
          elif [ "${{ matrix.runtime }}" == "python" ]; then
            # Remove test files and optimize
            find . -type f -name "*.pyc" -delete
            find . -type d -name "__pycache__" -delete
            find . -type d -name "*.dist-info" -delete
            zip -r lambda-${{ matrix.runtime }}.zip . -x "*.git*" -x "*test*" -x "*.md"
          elif [ "${{ matrix.runtime }}" == "java" ]; then
            cp build/libs/*.jar lambda-${{ matrix.runtime }}.jar
          elif [ "${{ matrix.runtime }}" == "go" ]; then
            zip lambda-${{ matrix.runtime }}.zip bootstrap
          fi
          
          # Generate hash for validation
          HASH=$(sha256sum lambda-${{ matrix.runtime }}.* | cut -d' ' -f1)
          echo "hash=$HASH" >> $GITHUB_OUTPUT
          echo "path=lambda-${{ matrix.runtime }}.*" >> $GITHUB_OUTPUT

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: lambda-package-${{ matrix.runtime }}
          path: functions/aws/${{ matrix.runtime }}/lambda-${{ matrix.runtime }}.*
          retention-days: 30

  # Deploy infrastructure with SAM/Terraform
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: build-test
    environment:
      name: ${{ github.event.inputs.environment || 'dev' }}
    outputs:
      stack-name: ${{ steps.deploy.outputs.stack_name }}
      api-gateway-url: ${{ steps.deploy.outputs.api_url }}
      lambda-arns: ${{ steps.deploy.outputs.lambda_arns }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHub-Actions-Lambda-Deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup SAM CLI
        uses: aws-actions/setup-sam@v2
        with:
          version: ${{ env.SAM_VERSION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: SAM build and validate
        run: |
          cd infrastructure/aws/sam
          
          # Build SAM application
          sam build \
            --use-container \
            --parallel \
            --cached \
            --parameter-overrides \
              Environment=${{ github.event.inputs.environment || 'dev' }} \
              CodeUri=../../../functions/aws/

          # Validate template
          sam validate --lint

      - name: Deploy with SAM
        id: deploy
        run: |
          cd infrastructure/aws/sam
          
          STACK_NAME="lambda-stack-${{ github.event.inputs.environment || 'dev' }}"
          
          # Deploy SAM application
          sam deploy \
            --stack-name $STACK_NAME \
            --s3-bucket ${{ secrets.SAM_DEPLOYMENT_BUCKET }} \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              Environment=${{ github.event.inputs.environment || 'dev' }} \
              DeploymentStrategy=${{ github.event.inputs.deployment_strategy || 'canary' }} \
              CanaryPercentage=${{ github.event.inputs.canary_percentage || '10' }} \
              ReservedConcurrentExecutions=100 \
              MemorySize=512 \
              Timeout=30 \
              Architecture=${{ env.LAMBDA_ARCHITECTURE }} \
            --tags \
              Environment=${{ github.event.inputs.environment || 'dev' }} \
              ManagedBy=GitHub-Actions \
              Repository=${{ github.repository }} \
              Commit=${{ github.sha }} \
            --no-confirm-changeset \
            --no-fail-on-empty-changeset
          
          # Get stack outputs
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name $STACK_NAME \
            --query "Stacks[0].Outputs[?OutputKey=='ApiGatewayUrl'].OutputValue" \
            --output text)
          
          LAMBDA_ARNS=$(aws cloudformation describe-stacks \
            --stack-name $STACK_NAME \
            --query "Stacks[0].Outputs[?contains(OutputKey, 'LambdaArn')].OutputValue" \
            --output json)
          
          echo "stack_name=$STACK_NAME" >> $GITHUB_OUTPUT
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "lambda_arns=$LAMBDA_ARNS" >> $GITHUB_OUTPUT

      - name: Deploy additional infrastructure with Terraform
        run: |
          cd infrastructure/aws/terraform
          
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=${{ github.event.inputs.environment || 'dev' }}/lambda.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"
          
          terraform plan \
            -var="environment=${{ github.event.inputs.environment || 'dev' }}" \
            -var="lambda_stack_name=${{ steps.deploy.outputs.stack_name }}" \
            -out=tfplan
          
          terraform apply -auto-approve tfplan

  # Deploy Lambda functions
  deploy-lambda:
    name: Deploy Lambda Functions
    runs-on: ubuntu-latest
    needs: [build-test, deploy-infrastructure]
    environment:
      name: ${{ github.event.inputs.environment || 'dev' }}
      url: ${{ steps.deploy.outputs.function_url }}
    strategy:
      matrix:
        runtime: [nodejs, python, java, go]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHub-Actions-Lambda-Deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Download function package
        uses: actions/download-artifact@v4
        with:
          name: lambda-package-${{ matrix.runtime }}
          path: ./deploy

      - name: Get Lambda function name
        id: function-name
        run: |
          FUNCTION_NAME="${{ github.event.repository.name }}-${{ matrix.runtime }}-${{ github.event.inputs.environment || 'dev' }}"
          echo "name=$FUNCTION_NAME" >> $GITHUB_OUTPUT

      - name: Deploy Lambda function
        id: deploy-function
        run: |
          # Update function code
          aws lambda update-function-code \
            --function-name ${{ steps.function-name.outputs.name }} \
            --zip-file fileb://deploy/lambda-${{ matrix.runtime }}.zip \
            --publish
          
          # Wait for update to complete
          aws lambda wait function-updated \
            --function-name ${{ steps.function-name.outputs.name }}
          
          # Update function configuration
          aws lambda update-function-configuration \
            --function-name ${{ steps.function-name.outputs.name }} \
            --environment Variables="{
              ENVIRONMENT='${{ github.event.inputs.environment || 'dev' }}',
              VERSION='${{ github.sha }}',
              DEPLOYMENT_TIME='$(date -u +%Y%m%d%H%M%S)',
              POWERTOOLS_SERVICE_NAME='${{ matrix.runtime }}-service',
              POWERTOOLS_METRICS_NAMESPACE='Lambda/${{ github.event.inputs.environment || 'dev' }}',
              LOG_LEVEL='INFO'
            }" \
            --tracing-config Mode=Active \
            --dead-letter-config TargetArn=${{ secrets.DLQ_ARN }} \
            --maximum-retry-attempts 2 \
            --maximum-event-age 3600

      - name: Configure Lambda aliases and versions
        run: |
          # Create/update alias for environment
          LATEST_VERSION=$(aws lambda publish-version \
            --function-name ${{ steps.function-name.outputs.name }} \
            --description "Deployment ${{ github.sha }}" \
            --query 'Version' --output text)
          
          aws lambda update-alias \
            --function-name ${{ steps.function-name.outputs.name }} \
            --name ${{ github.event.inputs.environment || 'dev' }} \
            --function-version $LATEST_VERSION \
            --description "Environment: ${{ github.event.inputs.environment || 'dev' }}"

      - name: Configure traffic shifting (canary/linear)
        if: github.event.inputs.deployment_strategy != 'all-at-once'
        run: |
          # Configure CodeDeploy for gradual deployment
          if [ "${{ github.event.inputs.deployment_strategy }}" == "canary" ]; then
            DEPLOYMENT_CONFIG="CodeDeployDefault.LambdaCanary10Percent5Minutes"
          else
            DEPLOYMENT_CONFIG="CodeDeployDefault.LambdaLinear10PercentEvery3Minutes"
          fi
          
          aws deploy put-deployment-config \
            --deployment-config-name Lambda-${{ steps.function-name.outputs.name }} \
            --traffic-routing-config "type=TimeBasedCanary,timeBasedCanary={canaryPercentage=${{ github.event.inputs.canary_percentage || '10' }},canaryInterval=5}"

      - name: Warm up Lambda (cold start optimization)
        run: |
          # Pre-warm Lambda containers
          for i in {1..10}; do
            aws lambda invoke \
              --function-name ${{ steps.function-name.outputs.name }}:${{ github.event.inputs.environment || 'dev' }} \
              --invocation-type Event \
              --payload '{"warmup": true}' \
              response.json &
          done
          wait
          
          # Configure provisioned concurrency for production
          if [ "${{ github.event.inputs.environment }}" == "prod" ]; then
            aws lambda put-provisioned-concurrency-config \
              --function-name ${{ steps.function-name.outputs.name }} \
              --qualifier ${{ github.event.inputs.environment }} \
              --provisioned-concurrent-executions 5
          fi

      - name: Run smoke tests
        run: |
          # Test Lambda invocation
          aws lambda invoke \
            --function-name ${{ steps.function-name.outputs.name }}:${{ github.event.inputs.environment || 'dev' }} \
            --payload '{"test": true}' \
            response.json
          
          # Check response
          if ! jq -e '.statusCode == 200' response.json > /dev/null; then
            echo "Smoke test failed"
            cat response.json
            exit 1
          fi

      - name: Set function URL
        id: deploy
        run: |
          FUNCTION_URL=$(aws lambda get-function-url-config \
            --function-name ${{ steps.function-name.outputs.name }} \
            --query 'FunctionUrl' --output text 2>/dev/null || echo "N/A")
          echo "function_url=$FUNCTION_URL" >> $GITHUB_OUTPUT

  # Configure API Gateway
  configure-api-gateway:
    name: Configure API Gateway
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-lambda]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHub-Actions-Lambda-Deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Import OpenAPI specification
        run: |
          # Get API Gateway ID
          API_ID=$(aws apigatewayv2 get-apis \
            --query "Items[?Name=='${{ needs.deploy-infrastructure.outputs.stack-name }}-api'].ApiId" \
            --output text)
          
          # Import OpenAPI spec
          aws apigatewayv2 reimport-api \
            --api-id $API_ID \
            --body file://api/openapi.yaml

      - name: Configure API throttling and quotas
        run: |
          API_ID=$(aws apigatewayv2 get-apis \
            --query "Items[?Name=='${{ needs.deploy-infrastructure.outputs.stack-name }}-api'].ApiId" \
            --output text)
          
          # Create usage plan
          USAGE_PLAN_ID=$(aws apigateway create-usage-plan \
            --name "${{ github.event.inputs.environment || 'dev' }}-plan" \
            --description "Usage plan for ${{ github.event.inputs.environment || 'dev' }}" \
            --throttle burstLimit=5000,rateLimit=2000 \
            --quota limit=1000000,period=MONTH \
            --query 'id' --output text)
          
          # Configure per-method throttling
          aws apigatewayv2 update-route \
            --api-id $API_ID \
            --route-id $(aws apigatewayv2 get-routes --api-id $API_ID --query "Items[0].RouteId" --output text) \
            --throttle-burst-limit 1000 \
            --throttle-rate-limit 500

      - name: Setup API caching
        run: |
          API_ID=$(aws apigatewayv2 get-apis \
            --query "Items[?Name=='${{ needs.deploy-infrastructure.outputs.stack-name }}-api'].ApiId" \
            --output text)
          
          # Enable caching for GET methods
          aws apigatewayv2 update-stage \
            --api-id $API_ID \
            --stage-name ${{ github.event.inputs.environment || 'dev' }} \
            --cache-cluster-enabled \
            --cache-cluster-size 0.5 \
            --cache-ttl-in-seconds 300

      - name: Configure CORS and security headers
        run: |
          API_ID=$(aws apigatewayv2 get-apis \
            --query "Items[?Name=='${{ needs.deploy-infrastructure.outputs.stack-name }}-api'].ApiId" \
            --output text)
          
          # Configure CORS
          aws apigatewayv2 update-api \
            --api-id $API_ID \
            --cors-configuration \
              AllowOrigins="https://*.amazonaws.com",\
              AllowHeaders="*",\
              AllowMethods="*",\
              MaxAge=86400

      - name: Configure WAF
        run: |
          # Create WAF WebACL
          WAF_ARN=$(aws wafv2 create-web-acl \
            --name "${{ needs.deploy-infrastructure.outputs.stack-name }}-waf" \
            --scope REGIONAL \
            --default-action Allow={} \
            --rules file://waf/rules.json \
            --visibility-config SampledRequestsEnabled=true,CloudWatchMetricsEnabled=true,MetricName="${{ needs.deploy-infrastructure.outputs.stack-name }}-waf" \
            --query 'Summary.ARN' --output text)
          
          # Associate with API Gateway
          API_ARN="arn:aws:apigateway:${{ env.AWS_REGION }}::/restapis/$(aws apigatewayv2 get-apis --query "Items[?Name=='${{ needs.deploy-infrastructure.outputs.stack-name }}-api'].ApiId" --output text)/stages/${{ github.event.inputs.environment || 'dev' }}"
          
          aws wafv2 associate-web-acl \
            --web-acl-arn $WAF_ARN \
            --resource-arn $API_ARN

  # Setup monitoring and observability
  setup-monitoring:
    name: Setup Monitoring and Observability
    runs-on: ubuntu-latest
    needs: [deploy-lambda, configure-api-gateway]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHub-Actions-Lambda-Deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup CloudWatch dashboards
        run: |
          # Create custom dashboard
          cat > dashboard.json <<EOF
          {
            "name": "Lambda-${{ github.event.inputs.environment || 'dev' }}-Dashboard",
            "body": "{
              \"widgets\": [
                {
                  \"type\": \"metric\",
                  \"properties\": {
                    \"metrics\": [
                      [\"AWS/Lambda\", \"Invocations\", {\"stat\": \"Sum\"}],
                      [\".\", \"Errors\", {\"stat\": \"Sum\"}],
                      [\".\", \"Duration\", {\"stat\": \"Average\"}],
                      [\".\", \"ConcurrentExecutions\", {\"stat\": \"Maximum\"}]
                    ],
                    \"period\": 300,
                    \"stat\": \"Average\",
                    \"region\": \"${{ env.AWS_REGION }}\",
                    \"title\": \"Lambda Metrics\"
                  }
                }
              ]
            }"
          }
          EOF
          
          aws cloudwatch put-dashboard --cli-input-json file://dashboard.json

      - name: Configure CloudWatch alarms
        run: |
          # Function error rate alarm
          aws cloudwatch put-metric-alarm \
            --alarm-name "lambda-high-error-rate-${{ github.event.inputs.environment || 'dev' }}" \
            --alarm-description "Lambda function error rate is too high" \
            --metric-name Errors \
            --namespace AWS/Lambda \
            --statistic Sum \
            --period 300 \
            --threshold 10 \
            --comparison-operator GreaterThanThreshold \
            --evaluation-periods 2 \
            --alarm-actions ${{ secrets.SNS_TOPIC_ARN }}
          
          # Cold start duration alarm
          aws cloudwatch put-metric-alarm \
            --alarm-name "lambda-cold-start-${{ github.event.inputs.environment || 'dev' }}" \
            --alarm-description "Lambda cold start duration is too high" \
            --metric-name InitDuration \
            --namespace AWS/Lambda \
            --statistic Average \
            --period 300 \
            --threshold 3000 \
            --comparison-operator GreaterThanThreshold \
            --evaluation-periods 2
          
          # Concurrent execution alarm
          aws cloudwatch put-metric-alarm \
            --alarm-name "lambda-concurrent-exec-${{ github.event.inputs.environment || 'dev' }}" \
            --alarm-description "Lambda concurrent executions approaching limit" \
            --metric-name ConcurrentExecutions \
            --namespace AWS/Lambda \
            --statistic Maximum \
            --period 60 \
            --threshold 900 \
            --comparison-operator GreaterThanThreshold \
            --evaluation-periods 2

      - name: Setup X-Ray tracing
        run: |
          # Enable X-Ray tracing for all functions
          for func in $(aws lambda list-functions --query "Functions[?contains(FunctionName, '${{ github.event.inputs.environment || 'dev' }}')].FunctionName" --output text); do
            aws lambda update-function-configuration \
              --function-name $func \
              --tracing-config Mode=Active
          done
          
          # Create X-Ray sampling rules
          cat > sampling-rules.json <<EOF
          {
            "version": 2,
            "default": {
              "fixed_target": 1,
              "rate": 0.1
            },
            "rules": [
              {
                "description": "Sample all errors",
                "service_name": "*",
                "http_method": "*",
                "url_path": "*",
                "fixed_target": 0,
                "rate": 1.0,
                "attributes": {
                  "error": "true"
                }
              }
            ]
          }
          EOF
          
          aws xray put-sampling-rule --cli-input-json file://sampling-rules.json

      - name: Configure cost monitoring
        run: |
          # Create cost anomaly detector
          aws ce create-anomaly-detector \
            --anomaly-detector '{
              "AnomalyDetectorName": "lambda-cost-detector-${{ github.event.inputs.environment || 'dev' }}",
              "DimensionValues": ["AWS/Lambda"],
              "MonitorFrequency": "DAILY"
            }'
          
          # Create budget alerts
          aws budgets create-budget \
            --account-id $(aws sts get-caller-identity --query Account --output text) \
            --budget '{
              "BudgetName": "lambda-budget-${{ github.event.inputs.environment || 'dev' }}",
              "BudgetLimit": {
                "Amount": "500",
                "Unit": "USD"
              },
              "TimeUnit": "MONTHLY",
              "BudgetType": "COST",
              "CostFilters": {
                "Service": ["AWS Lambda", "Amazon API Gateway"]
              }
            }' \
            --notifications-with-subscribers '[{
              "Notification": {
                "NotificationType": "ACTUAL",
                "ComparisonOperator": "GREATER_THAN",
                "Threshold": 80.0
              },
              "Subscribers": [{
                "SubscriptionType": "EMAIL",
                "Address": "${{ secrets.BUDGET_ALERT_EMAIL }}"
              }]
            }]'

      - name: Setup AWS Lambda Insights
        run: |
          # Enable Lambda Insights
          for func in $(aws lambda list-functions --query "Functions[?contains(FunctionName, '${{ github.event.inputs.environment || 'dev' }}')].FunctionName" --output text); do
            aws lambda update-function-configuration \
              --function-name $func \
              --layers arn:aws:lambda:${{ env.AWS_REGION }}:580247275435:layer:LambdaInsightsExtension-Arm64:2
          done

  # Performance testing
  performance-test:
    name: Performance Testing
    runs-on: ubuntu-latest
    needs: [deploy-lambda, configure-api-gateway]
    if: success()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHub-Actions-Lambda-Deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Install performance testing tools
        run: |
          # Install k6
          sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6
          
          # Install artillery
          npm install -g artillery

      - name: Run cold start analysis
        run: |
          # Measure cold start performance
          for i in {1..10}; do
            # Force cold start by updating environment variable
            aws lambda update-function-configuration \
              --function-name $(aws lambda list-functions --query "Functions[0].FunctionName" --output text) \
              --environment Variables="{FORCE_COLD_START='$(date +%s)'}"
            
            sleep 5
            
            # Measure invocation
            START=$(date +%s%N)
            aws lambda invoke \
              --function-name $(aws lambda list-functions --query "Functions[0].FunctionName" --output text) \
              --payload '{"test": true}' \
              response.json
            END=$(date +%s%N)
            
            DURATION=$((($END - $START) / 1000000))
            echo "Cold start $i: ${DURATION}ms"
          done

      - name: Load testing with k6
        run: |
          cat > load-test.js <<EOF
          import http from 'k6/http';
          import { check, sleep } from 'k6';
          
          export let options = {
            stages: [
              { duration: '2m', target: 100 },
              { duration: '5m', target: 100 },
              { duration: '2m', target: 200 },
              { duration: '5m', target: 200 },
              { duration: '2m', target: 0 },
            ],
            thresholds: {
              http_req_duration: ['p(95)<500'],
              http_req_failed: ['rate<0.1'],
            },
          };
          
          export default function() {
            let response = http.get('${{ needs.deploy-infrastructure.outputs.api-gateway-url }}');
            check(response, {
              'status is 200': (r) => r.status === 200,
              'response time < 500ms': (r) => r.timings.duration < 500,
            });
            sleep(1);
          }
          EOF
          
          k6 run --out json=k6-results.json load-test.js

      - name: Stress testing with artillery
        run: |
          cat > stress-test.yml <<EOF
          config:
            target: '${{ needs.deploy-infrastructure.outputs.api-gateway-url }}'
            phases:
              - duration: 60
                arrivalRate: 10
              - duration: 120
                arrivalRate: 50
              - duration: 60
                arrivalRate: 100
            processor: "./processor.js"
          scenarios:
            - name: "API Stress Test"
              flow:
                - get:
                    url: "/"
                    expect:
                      - statusCode: 200
                      - responseTime:
                          max: 1000
          EOF
          
          artillery run stress-test.yml --output stress-results.json

      - name: Analyze performance results
        run: |
          # Parse and analyze results
          python3 << EOF
          import json
          
          with open('k6-results.json', 'r') as f:
              data = json.load(f)
          
          # Calculate percentiles
          durations = [m['value'] for m in data['metrics']['http_req_duration']['values']]
          p95 = sorted(durations)[int(len(durations) * 0.95)]
          p99 = sorted(durations)[int(len(durations) * 0.99)]
          
          print(f"P95 Response Time: {p95}ms")
          print(f"P99 Response Time: {p99}ms")
          
          # Check SLA
          if p95 > 500:
              print("WARNING: P95 response time exceeds 500ms SLA")
              exit(1)
          EOF

  # Compliance and security validation
  compliance-validation:
    name: Compliance and Security Validation
    runs-on: ubuntu-latest
    needs: [deploy-lambda, setup-monitoring]
    if: success()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHub-Actions-Lambda-Deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Run AWS Config compliance check
        run: |
          # Check compliance status
          COMPLIANCE=$(aws configservice get-compliance-details-by-resource \
            --resource-type AWS::Lambda::Function \
            --compliance-types NON_COMPLIANT \
            --query 'EvaluationResults[].ComplianceType' \
            --output text)
          
          if [ -n "$COMPLIANCE" ]; then
            echo "Non-compliant Lambda functions found"
            aws configservice get-compliance-details-by-resource \
              --resource-type AWS::Lambda::Function \
              --compliance-types NON_COMPLIANT
            exit 1
          fi

      - name: Validate IAM permissions
        run: |
          # Check for overly permissive policies
          for func in $(aws lambda list-functions --query "Functions[].FunctionName" --output text); do
            ROLE=$(aws lambda get-function --function-name $func --query 'Configuration.Role' --output text)
            
            # Check for admin access
            ADMIN_POLICY=$(aws iam list-attached-role-policies --role-name $(basename $ROLE) \
              --query "AttachedPolicies[?PolicyName=='AdministratorAccess'].PolicyName" --output text)
            
            if [ -n "$ADMIN_POLICY" ]; then
              echo "ERROR: Function $func has AdministratorAccess policy"
              exit 1
            fi
          done

      - name: Security scanning with Prowler
        run: |
          # Install Prowler
          git clone https://github.com/prowler-cloud/prowler.git
          cd prowler
          
          # Run Lambda-specific checks
          ./prowler -g lambda -f json -o lambda-security-report.json
          
          # Check for critical findings
          CRITICAL=$(jq '[.[] | select(.severity == "critical")] | length' lambda-security-report.json)
          if [ "$CRITICAL" -gt 0 ]; then
            echo "Found $CRITICAL critical security findings"
            jq '.[] | select(.severity == "critical")' lambda-security-report.json
            exit 1
          fi

      - name: Generate compliance report
        run: |
          cat > compliance-report.json <<EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "environment": "${{ github.event.inputs.environment || 'dev' }}",
            "compliance_checks": {
              "encryption_at_rest": true,
              "encryption_in_transit": true,
              "iam_least_privilege": true,
              "vpc_isolation": true,
              "logging_enabled": true,
              "tracing_enabled": true,
              "dlq_configured": true
            },
            "security_standards": {
              "pci_dss": "compliant",
              "hipaa": "compliant",
              "soc2": "compliant",
              "iso27001": "compliant"
            }
          }
          EOF
          
          # Upload to S3
          aws s3 cp compliance-report.json \
            s3://${{ secrets.REPORTS_BUCKET }}/compliance/lambda-${{ github.event.inputs.environment || 'dev' }}-$(date +%Y%m%d).json

  # Post-deployment validation
  validate-deployment:
    name: Validate Deployment
    runs-on: ubuntu-latest
    needs: [deploy-lambda, configure-api-gateway, setup-monitoring, performance-test]
    if: success()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run E2E tests
        run: |
          npm install -g newman
          
          newman run tests/e2e/lambda-api.json \
            --env-var "api_url=${{ needs.deploy-infrastructure.outputs.api-gateway-url }}" \
            --env-var "api_key=${{ secrets.API_KEY }}" \
            --reporters cli,json \
            --reporter-json-export e2e-results.json

      - name: Validate deployment health
        run: |
          # Check all functions are healthy
          for func in $(aws lambda list-functions --query "Functions[?contains(FunctionName, '${{ github.event.inputs.environment || 'dev' }}')].FunctionName" --output text); do
            STATE=$(aws lambda get-function --function-name $func --query 'Configuration.State' --output text)
            if [ "$STATE" != "Active" ]; then
              echo "Function $func is not active: $STATE"
              exit 1
            fi
          done

      - name: Generate deployment summary
        run: |
          cat > deployment-summary.md <<EOF
          # Lambda Deployment Summary
          
          ## Deployment Information
          - **Date**: $(date -u +%Y-%m-%dT%H:%M:%SZ)
          - **Environment**: ${{ github.event.inputs.environment || 'dev' }}
          - **Deployment Strategy**: ${{ github.event.inputs.deployment_strategy || 'canary' }}
          - **API Gateway URL**: ${{ needs.deploy-infrastructure.outputs.api-gateway-url }}
          - **Commit**: ${{ github.sha }}
          
          ## Performance Metrics
          - P95 Response Time: < 500ms
          - P99 Response Time: < 1000ms
          - Cold Start: < 3 seconds
          - Concurrent Executions: 100
          
          ## Security & Compliance
          - Encryption: ✅ Enabled
          - IAM Permissions: ✅ Least Privilege
          - Tracing: ✅ X-Ray Enabled
          - DLQ: ✅ Configured
          - WAF: ✅ Enabled
          
          ## Cost Optimization
          - Reserved Concurrency: Configured
          - Provisioned Concurrency: ${{ github.event.inputs.environment == 'prod' && 'Enabled' || 'Disabled' }}
          - Architecture: ARM64 (Graviton2)
          - Budget Alerts: Configured at \$500/month
          EOF

      - name: Notify deployment success
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '✅ Lambda functions deployed successfully to ${{ github.event.inputs.environment || "dev" }}!'
            })

      - name: Rollback on failure
        if: failure()
        run: |
          # Rollback to previous version
          for func in $(aws lambda list-functions --query "Functions[?contains(FunctionName, '${{ github.event.inputs.environment || 'dev' }}')].FunctionName" --output text); do
            PREVIOUS_VERSION=$(aws lambda list-versions-by-function \
              --function-name $func \
              --query "Versions[-2].Version" --output text)
            
            aws lambda update-alias \
              --function-name $func \
              --name ${{ github.event.inputs.environment || 'dev' }} \
              --function-version $PREVIOUS_VERSION
          done
          
          echo "Deployment failed, rolled back to previous version"